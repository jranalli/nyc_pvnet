import os
import math
import uuid
import json

import numpy as np

import PIL.Image
import PIL.ImageDraw

from fileio import verify_dir, files_of_type


def shape_to_mask(img_shape, points, shape_type=None,
                  line_width=10, point_size=5):
    """
    Converts a fundamental shape from a labelme file to a mask.

    Directly copied from labelme.utils: https://github.com/wkentaro/labelme
    Eliminates full dependency on labelme

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    points: list
        List of points making up the shape
    shape_type: str
        Type of the shape
    line_width: int
        Width of the line (used only for certain types)
    point_size: ing
        Size of point, used only for certain types

    Returns
    -------
    mask: np.array
        the image mask
    """
    mask = np.zeros(img_shape[:2], dtype=np.uint8)
    mask = PIL.Image.fromarray(mask)
    draw = PIL.ImageDraw.Draw(mask)
    xy = [tuple(point) for point in points]
    if shape_type == "circle":
        assert len(xy) == 2, "Shape of shape_type=circle must have 2 points"
        (cx, cy), (px, py) = xy
        d = math.sqrt((cx - px) ** 2 + (cy - py) ** 2)
        draw.ellipse([cx - d, cy - d, cx + d, cy + d], outline=1, fill=1)
    elif shape_type == "rectangle":
        assert len(xy) == 2, "Shape of shape_type=rectangle must have 2 points"
        draw.rectangle(xy, outline=1, fill=1)
    elif shape_type == "line":
        assert len(xy) == 2, "Shape of shape_type=line must have 2 points"
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "linestrip":
        draw.line(xy=xy, fill=1, width=line_width)
    elif shape_type == "point":
        assert len(xy) == 1, "Shape of shape_type=point must have 1 points"
        cx, cy = xy[0]
        r = point_size
        draw.ellipse([cx - r, cy - r, cx + r, cy + r], outline=1, fill=1)
    else:
        assert len(xy) > 2, "Polygon must have points more than 2"
        draw.polygon(xy=xy, outline=1, fill=1)
    mask = np.array(mask, dtype=bool)
    return mask


def shapes_to_label(img_shape, shapes, label_name_to_value):
    """
    Directly copied from labelme.utils: https://github.com/wkentaro/labelme
    Eliminates full dependency on labelme

    Parameters
    ----------
    img_shape: tuple
        The (height, width) of the image
    shapes:
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array

    Returns
    -------
    cls: np.array
        binary mask image
    ins: np.array
        mask of instance ids for each shape

    """
    cls = np.zeros(img_shape[:2], dtype=np.int32)
    ins = np.zeros_like(cls)
    instances = []
    for shape in shapes:
        points = shape["points"]
        label = shape["label"]
        group_id = shape.get("group_id")
        if group_id is None:
            group_id = uuid.uuid1()
        shape_type = shape.get("shape_type", None)

        cls_name = label
        instance = (cls_name, group_id)

        if instance not in instances:
            instances.append(instance)
        ins_id = instances.index(instance) + 1
        cls_id = label_name_to_value[cls_name]

        mask = shape_to_mask(img_shape[:2], points, shape_type)
        cls[mask] = cls_id
        ins[mask] = ins_id

    return cls, ins


def json_to_binary(json_file, out, label_name_to_value, imgtype="png"):
    """
    Adapted from labelme.cli.json_to_dataset
            - https://github.com/wkentaro/labelme

    Takes a JSON file generated by labelme and converts it to a binary image
    mask representing the location of objects labelled in the image.

    Parameters
    ----------
    json_file: str
        Path to the labelme generated JSON shape file.
    out: str
        Full path to the file output directory. Output will be PNG file
    label_name_to_value: dict
        a dict connecting polygon label names to the numeric id that should be
        displayed in the output array
    imgtype: str (default "png")
        str of the file extension for the output image.
    """
    if out is None:
        out_dir = os.path.basename(json_file).replace(".", "_")
        out_dir = os.path.join(os.path.dirname(json_file), out_dir)
    else:
        out_dir = out

    verify_dir(out_dir)

    data = json.load(open(json_file))
    imshape = (data['imageHeight'], data['imageWidth'])

    # Create numeric label values for any labels not in label_name_to_value
    value_pairs = label_name_to_value.copy()  # copy to avoid altering
    for shape in sorted(data["shapes"], key=lambda x: x["label"]):
        label_name = shape["label"]
        if label_name not in value_pairs:
            label_value = len(value_pairs)
            value_pairs[label_name] = label_value

    # Convert shapes to mask
    lbl, _ = shapes_to_label(imshape, data["shapes"], value_pairs)
    lbl_pil = PIL.Image.fromarray(lbl.astype(np.uint8), mode="P")

    # Generate the output filename
    out_fn = os.path.basename(json_file).replace(".json", "."+imgtype)
    lbl_pil.save(os.path.join(out_dir, out_fn))


# Example directories to test
target_dir = 'C:\\nycdata\\boro_queens_sp18_png\\'
ot_dir = 'C:\\nycdata\\boro_queens_sp18_out\\'

if __name__ == "__main__":
    label_id_dict = {"_background_": 0, "maybe": 0, "notpv": 0, "pv": 255}

    for fn in files_of_type(target_dir, "*.json"):
        json_to_binary(fn, ot_dir, label_id_dict)
